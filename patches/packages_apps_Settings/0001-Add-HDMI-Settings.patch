From b9c07d389aed1cf5aff75ffa00a86c791e8a20c7 Mon Sep 17 00:00:00 2001
From: fefifofum <fefifofum@email.com>
Date: Tue, 12 Nov 2013 10:15:21 +0100
Subject: Add HDMI settings

---
 AndroidManifest.xml                                |   7 +
 proguard.flags                                     |   3 +
 res/layout/preference_dialog_screen_scale.xml      |  45 ++
 res/values-es/arrays.xml                           |   6 +
 res/values-es/strings.xml                          |  19 +
 res/values/arrays.xml                              |  32 ++
 res/values/strings.xml                             |  20 +
 res/xml/hdmi_settings.xml                          |  38 ++
 res/xml/hdmi_settings_timeout.xml                  |  43 ++
 res/xml/settings_headers.xml                       |   7 +
 .../android/settings/HdmiControllerActivity.java   | 622 +++++++++++++++++++++
 src/com/android/settings/HdmiReceiver.java         | 350 ++++++++++++
 .../android/settings/HdmiScreenZoomPreference.java | 238 ++++++++
 src/com/android/settings/Settings.java             |  16 +
 14 files changed, 1446 insertions(+)
 create mode 100644 res/layout/preference_dialog_screen_scale.xml
 create mode 100644 res/xml/hdmi_settings.xml
 create mode 100644 res/xml/hdmi_settings_timeout.xml
 create mode 100644 src/com/android/settings/HdmiControllerActivity.java
 create mode 100644 src/com/android/settings/HdmiReceiver.java
 create mode 100644 src/com/android/settings/HdmiScreenZoomPreference.java

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 46c0142..20ff750 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -1725,6 +1725,13 @@
             <meta-data android:name="android.appwidget.provider" android:resource="@xml/appwidget_info" />
         </receiver>
 
+        <!--set HDMI scale value when system boot -->
+        <receiver android:name="HdmiReceiver">
+            <intent-filter>
+                <action android:name="android.intent.action.HDMI_AUDIO_PLUG"/>
+            </intent-filter>
+        </receiver>
+
         <receiver android:name=".bluetooth.BluetoothDiscoverableTimeoutReceiver">
             <intent-filter>
                 <action android:name="android.bluetooth.intent.DISCOVERABLE_TIMEOUT" />
diff --git a/proguard.flags b/proguard.flags
index d0862da..b9776eb 100644
--- a/proguard.flags
+++ b/proguard.flags
@@ -11,6 +11,9 @@
 -keep class com.android.settings.MasterClearConfirm
 -keep class com.android.settings.accounts.*
 -keep class com.android.settings.fuelgauge.*
+-keep class com.android.settings.HdmiControllerActivity
+-keep class com.android.settings.HdmiReceiver
+-keep class com.android.settings.HdmiScreenZoomPreference
 -keep class com.android.settings.users.*
 -keep class com.koushikdutta.**
 -keep class com.android.settings.cyanogenmod.superuser.**
diff --git a/res/layout/preference_dialog_screen_scale.xml b/res/layout/preference_dialog_screen_scale.xml
new file mode 100644
index 0000000..41a3026
--- /dev/null
+++ b/res/layout/preference_dialog_screen_scale.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2008 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+
+     Copyright (C) 2009 Motorola, Inc.
+     March 23, 2009 - Motorola - Allow automatic brightness changes.
+-->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="vertical"
+            android:gravity="center_horizontal"
+            android:paddingBottom="20dip">
+
+		
+        <ImageView android:id="@android:id/icon"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:paddingTop="20dip"
+                android:visibility="gone" />
+			
+
+        <SeekBar android:id="@*android:id/seekbar"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+				android:max="20"
+                android:padding="20dip" />
+
+    </LinearLayout>
+</ScrollView>
diff --git a/res/values-es/arrays.xml b/res/values-es/arrays.xml
index 564f631..ed2c0a6 100644
--- a/res/values-es/arrays.xml
+++ b/res/values-es/arrays.xml
@@ -295,4 +295,10 @@
     <item msgid="5077768429488260031">"No permitir nunca"</item>
     <item msgid="1417929597727989746">"Permitir siempre"</item>
   </string-array>
+  <string-array name="hdmi_lcd_timeout_entries">
+    <item>10s</item>
+    <item>20s</item>
+    <item>30s</item>
+    <item>No apagar pantalla</item>
+  </string-array>
 </resources>
diff --git a/res/values-es/strings.xml b/res/values-es/strings.xml
index 3b5ef23..a2fbdfe 100644
--- a/res/values-es/strings.xml
+++ b/res/values-es/strings.xml
@@ -16,6 +16,7 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="hdmi_lcd_timeout">Tiempo de espera</string>
     <string name="yes" msgid="4676390750360727396">"Sí"</string>
     <string name="no" msgid="6731231425810196216">"No"</string>
     <string name="create" msgid="3578857613172647409">"Crear"</string>
@@ -1791,6 +1794,9 @@
     <string name="selinux_status_disabled" msgid="924551035552323327">"Inhabilitado"</string>
     <string name="selinux_status_permissive" msgid="6004965534713398778">"Permisivo"</string>
     <string name="selinux_status_enforcing" msgid="2252703756208463329">"Obligatorio"</string>
+    <string name="hdmi_screen_zoom">Zoom de pantalla</string>
+    <string name="hdmi_resolution_title">Resolución HDMI</string>
+    <string name="hdmi_title">Activar HDMI</string>
     <string name="user_settings_title" msgid="6151874007858148344">"Usuarios"</string>
     <string name="user_you_section" msgid="6247838798859425408">"Tú"</string>
     <string name="user_list_title" msgid="8866161687358773982">"Otros usuarios"</string>
diff --git a/res/values/arrays.xml b/res/values/arrays.xml
index 14e1fc8..240d7d0 100644
--- a/res/values/arrays.xml
+++ b/res/values/arrays.xml
@@ -744,6 +744,25 @@
         <!-- Status message when VPN is failed. -->
         <item>Unsuccessful</item>
     </string-array>
+    
+    <!--HDMI-->
+    <string-array name="hdmi_resolution_entries">
+        <item>1920x1080p_50Hz </item>
+        <item>1920x1080p_60Hz</item>
+        <item>1280x720p_50Hz</item>
+        <item>1280x720p_60Hz</item>
+        <item>720x576p_50Hz </item>
+        <item>720x480p_60Hz </item>
+    </string-array>
+
+    <string-array name="hdmi_resolution_values">
+        <item>1</item>
+        <item>2</item>
+        <item>3</item>
+        <item>4</item>
+        <item>5</item>
+        <item>6</item>
+    </string-array>
 
     <!-- User content ratings for restricted users [CHAR LIMIT=30] -->
     <string-array name="user_content_ratings_entries" translatable="false">
@@ -763,6 +782,19 @@
         <item>1</item>
     </string-array>
 
+    <string-array name="hdmi_lcd_timeout_entries">
+        <item>10s</item>
+        <item>20s</item>
+        <item>30s</item>
+        <item>never sleep</item>
+    </string-array>
+    <string-array name="hdmi_lcd_timeout_values">
+        <item>1</item>
+        <item>2</item>
+        <item>3</item>
+        <item>-1</item>
+    </string-array>
+
     <!-- Values for premium SMS permission selector [CHAR LIMIT=30] -->
     <string-array name="security_settings_premium_sms_values">
         <!-- Ask user before sending to premium SMS short code. -->
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 912782d..79fa4e4 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -14,6 +14,10 @@
      limitations under the License.
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="hdmi_lcd_timeout">Screen Timeout</string>
+    <string name="hdmi_plugin">HDMI connect</string>
+    <string name="hdmi_extract">HDMI disconnect</string>
+
     <!-- Strings for Dialog yes button -->
     <string name="yes">"Yes"</string>
 
@@ -4260,6 +4264,22 @@
     <string name="selinux_status_permissive">Permissive</string>
     <string name="selinux_status_enforcing">Enforcing</string>
 
+    <!--HDMI-->
+    <string name="hdmi_settings">HDMI</string>
+    <string name="HDCP_Setting_title">HDCP</string>
+    <string name="hdmi_screen_zoom">Screen Zoom</string>
+ 
+    <string name="hdmi_notice">Please connect the HDMI cable</string>
+    <string name="display_notice">Please make sure the HDMI is closed</string>
+    <string name="hdmi_resolution_title">HDMI Resolution</string>
+    <string name="hdmi_resolution_summary_on">select different resolution for hdmi</string>
+    <string name="hdmi_resolution_off">select different resolution for hdmi	</string>
+    <string name="hdmi_mode_title">HDMI Mode</string>
+    <string name="hdmi_mode_summary_on">select different working mode for hdmi</string>
+    <string name="hdmi_mode_off">select different working mode for hdmi	</string>
+    <string name="hdmi_title">Turn on HDMI</string>
+    <string name="HDMI_TV_Display">Adjust the display resolution of the screen</string>
+
     <!-- User settings -->
     <skip/>
 
diff --git a/res/xml/hdmi_settings.xml b/res/xml/hdmi_settings.xml
new file mode 100644
index 0000000..cfaffe8
--- /dev/null
+++ b/res/xml/hdmi_settings.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android" >
+<CheckBoxPreference
+            android:key="hdmi"
+            android:title="@string/hdmi_title"
+            android:defaultValue="true"/>
+<!--
+        <ListPreference
+          android:key="hdmi_mode" 
+          android:title="@string/hdmi_mode_title"
+		  android:dependency="hdmi"
+          android:persistent="false"
+          android:entries="@array/hdmi_mode_entries"
+          android:entryValues="@array/hdmi_mode_values"/>
+  -->
+		<ListPreference
+		  android:key="hdmi_resolution"	
+          android:title="@string/hdmi_resolution_title"
+          android:persistent="true"
+		  android:dependency="hdmi"
+          android:entries="@array/hdmi_resolution_entries"
+          android:entryValues="@array/hdmi_resolution_values"
+          android:defaultValue="2"/>
+<!--  
+        <CheckBoxPreference
+            android:key="HDCP_Setting"
+            android:title="@string/HDCP_Setting_title"
+		  	android:dependency="hdmi"
+			android:visibility="gone"/>
+-->
+		<com.android.settings.HdmiScreenZoomPreference
+			android:key="hdmi_screen_zoom"
+			android:title="@string/hdmi_screen_zoom"
+			android:dependency="hdmi"
+			android:dialogTitle="@string/hdmi_screen_zoom"/>
+    
+
+</PreferenceScreen>
diff --git a/res/xml/hdmi_settings_timeout.xml b/res/xml/hdmi_settings_timeout.xml
new file mode 100644
index 0000000..8472bf9
--- /dev/null
+++ b/res/xml/hdmi_settings_timeout.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android" >
+<CheckBoxPreference
+            android:key="hdmi"
+            android:title="@string/hdmi_title"
+            android:defaultValue="true"/>
+<!--
+        <ListPreference
+          android:key="hdmi_mode" 
+          android:title="@string/hdmi_mode_title"
+		  android:dependency="hdmi"
+          android:persistent="false"
+          android:entries="@array/hdmi_mode_entries"
+          android:entryValues="@array/hdmi_mode_values"/>
+  -->
+		<ListPreference
+		  android:key="hdmi_resolution"	
+          android:title="@string/hdmi_resolution_title"
+          android:persistent="true"
+		  android:dependency="hdmi"
+          android:entries="@array/hdmi_resolution_entries"
+          android:entryValues="@array/hdmi_resolution_values"
+          android:defaultValue="2"/>
+<!--  
+        <CheckBoxPreference
+            android:key="HDCP_Setting"
+            android:title="@string/HDCP_Setting_title"
+		  	android:dependency="hdmi"
+			android:visibility="gone"/>
+-->
+		<com.android.settings.HdmiScreenZoomPreference
+			android:key="hdmi_screen_zoom"
+			android:title="@string/hdmi_screen_zoom"
+			android:dependency="hdmi"
+			android:dialogTitle="@string/hdmi_screen_zoom"/>
+        <ListPreference
+           android:key="hdmi_lcd_timeout" 
+           android:title="@string/hdmi_lcd_timeout"
+           android:entries="@array/hdmi_lcd_timeout_entries"
+           android:entryValues="@array/hdmi_lcd_timeout_values"
+		/>    
+
+</PreferenceScreen>
diff --git a/res/xml/settings_headers.xml b/res/xml/settings_headers.xml
index bdc394a..0fb4018 100644
--- a/res/xml/settings_headers.xml
+++ b/res/xml/settings_headers.xml
@@ -111,6 +111,13 @@
         android:fragment="com.android.settings.DisplaySettings"
         android:title="@string/display_settings" />
 
+    <!-- Hdmi -->
+    <header
+        android:id="@+id/hdmi_settings"
+        android:icon="@drawable/ic_settings_hdmi"
+        android:fragment="com.android.settings.HdmiControllerActivity"
+        android:title="@string/hdmi_settings" />
+
     <!-- Storage -->
     <header
         android:id="@+id/storage_settings"
diff --git a/src/com/android/settings/HdmiControllerActivity.java b/src/com/android/settings/HdmiControllerActivity.java
new file mode 100644
index 0000000..816fc3d
--- /dev/null
+++ b/src/com/android/settings/HdmiControllerActivity.java
@@ -0,0 +1,622 @@
+package com.android.settings;
+import android.util.Log;
+import static android.provider.Settings.System.SCREEN_OFF_TIMEOUT;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.RandomAccessFile;
+import android.os.SystemProperties;
+import android.app.Activity;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+import android.util.Log;
+import android.widget.Toast;
+//import static android.provider.Settings.System.HDMI_LCD_TIMEOUT;
+import android.content.ContentResolver;
+import android.os.Handler;
+import android.database.ContentObserver;
+public class HdmiControllerActivity extends SettingsPreferenceFragment implements OnPreferenceChangeListener {
+    /** Called when the activity is first created. */
+	 private static final String TAG = "HdmiControllerActivity";
+	    private static final String KEY_HDMI_RESOLUTION = "hdmi_resolution";
+	    private static final String KEY_HDMI_MODE = "hdmi_mode";
+	    private static final String KEY_HDMI = "hdmi";
+	    private static final String KEY_HDCP = "HDCP_Setting";
+            private static final String KEY_HDMI_LCD ="hdmi_lcd_timeout";
+	    //for identify the HdmiFile state
+	    private boolean IsHdmiConnect=false;
+	    //for identify the Hdmi connection state
+	    private boolean IsHdmiPlug = false;
+	    private boolean IsHdmiDisplayOn = false;
+
+	    private CheckBoxPreference mHdmi;
+	    private CheckBoxPreference mHdcp;
+	    private ListPreference     mHdmiResolution;
+	    private ListPreference     mHdmiMode;
+            private ListPreference     mHdmiLcd;
+
+
+	    private File HdmiFile = null;
+	    private File HdmiState = null;
+	    private File HdmiDisplayEnable=null;
+	    private File HdmiDisplayMode=null;
+	    private File HdmiDisplayConnect=null;
+            private Context context;
+            private static final int DEF_HDMI_LCD_TIMEOUT_VALUE = 10;
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        context=getActivity();
+        if(!isDualMode()){
+           addPreferencesFromResource(R.xml.hdmi_settings);
+        }else{
+           addPreferencesFromResource(R.xml.hdmi_settings_timeout);
+           mHdmiLcd = (ListPreference)findPreference(KEY_HDMI_LCD);                
+           mHdmiLcd.setOnPreferenceChangeListener(this);
+           ContentResolver resolver = context.getContentResolver();
+           long lcdTimeout = -1;
+           if((lcdTimeout = Settings.System.getLong(resolver, Settings.System.HDMI_LCD_TIMEOUT,
+              DEF_HDMI_LCD_TIMEOUT_VALUE)) > 0)
+              {
+                   lcdTimeout/=10;
+              }
+           mHdmiLcd.setValue(String.valueOf(lcdTimeout));
+        }
+        HdmiFile = new File("/sys/class/hdmi/hdmi-0/enable");
+	HdmiState = new File("/sys/class/hdmi/hdmi-0/state");
+        HdmiDisplayEnable=new File("/sys/class/display/HDMI/enable");
+        HdmiDisplayMode=new File("/sys/class/display/HDMI/mode");
+        HdmiDisplayConnect=new File("sys/class/display/HDMI/connect");
+	mHdmi = (CheckBoxPreference)findPreference(KEY_HDMI);
+		
+	mHdmiResolution = (ListPreference)findPreference(KEY_HDMI_RESOLUTION);
+        mHdmiResolution.setOnPreferenceChangeListener(this);
+		
+         
+    }
+
+   private ContentObserver mHdmiTimeoutSettingObserver = new ContentObserver(new Handler()) {
+       @Override
+       public void onChange(boolean selfChange) {
+
+              ContentResolver resolver = getActivity().getContentResolver();
+                      final long currentTimeout = Settings.System.getLong(resolver, Settings.System.HDMI_LCD_TIMEOUT,
+                      -1);
+              long lcdTimeout = -1;
+              if((lcdTimeout = Settings.System.getLong(resolver, Settings.System.HDMI_LCD_TIMEOUT,
+              DEF_HDMI_LCD_TIMEOUT_VALUE)) > 0)
+              {
+                   lcdTimeout/=10;
+              }
+              mHdmiLcd.setValue(String.valueOf(lcdTimeout));
+       }
+   };    
+
+    @Override
+    public void onResume() {
+    	// TODO Auto-generated method stub
+    	
+    	super.onResume();
+        getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.HDMI_LCD_TIMEOUT), true,
+                mHdmiTimeoutSettingObserver);
+    }
+
+    public void onPause(){
+        super.onPause();
+       // getContentResolver().unregisterContentObserver(mHdmiTimeoutSettingObserver);
+   }
+   
+   public void onDestroy(){
+        super.onDestroy();
+        getContentResolver().unregisterContentObserver(mHdmiTimeoutSettingObserver);
+   }
+
+    private boolean isDualMode(){
+		boolean isDualMode=false;
+		File file=new File("/sys/class/graphics/fb0/dual_mode");
+		if(file.exists()){
+			try{
+				FileReader fread=new FileReader(file);
+				BufferedReader buffer=new BufferedReader(fread);
+				String str=null;
+				while((str=buffer.readLine())!=null){
+					if(!str.equals("0")){
+						isDualMode=true;
+					}
+				}
+			}catch(Exception e){
+				e.printStackTrace();
+			}
+		}
+		return isDualMode;
+    }
+
+    protected static boolean isHdmiEnableDoubleScreen(File file){
+        boolean isEnableDoubleScreen = false;
+        if (file.exists()){
+            try {
+                  FileReader       fread = new FileReader(file);
+                  BufferedReader   buffer = new BufferedReader(fread);
+                  String           strPlug = "dual_disp=1";
+                  String           str = null;
+
+                  while ((str = buffer.readLine()) != null){
+                    int length = str.length();
+                    if((length == 11) && (str.equals(strPlug))){
+                        isEnableDoubleScreen = true;
+                        break;
+                    }
+                    else{
+                        isEnableDoubleScreen = false;
+                    }
+                  }
+            } catch (IOException e){
+                Log.e(TAG, "IO Exception");
+            }
+        }
+        return isEnableDoubleScreen;
+    }
+    
+    protected void setHdmiConfig(File file, boolean enable) {
+
+	if(SystemProperties.get("ro.board.platform","none").equals("rk29xx")){	
+	   if (file.exists()) {
+		try {
+		   SharedPreferences  sharedPreferences1 = getActivity().getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+		   SharedPreferences.Editor editor = sharedPreferences1.edit();
+		   String strDouble = "2";
+		   String strChecked = "1";
+		   String strUnChecked = "0";
+		   RandomAccessFile rdf = null;
+		   rdf = new RandomAccessFile(file, "rw");	
+		   if (enable) {
+		      if(isHdmiEnableDoubleScreen(HdmiState)){
+			rdf.writeBytes(strDouble);
+                        editor.putInt("enable", 2);
+		      }else{
+			rdf.writeBytes(strChecked);
+			editor.putInt("enable", 1);
+		      }
+		   } else {
+			rdf.writeBytes(strUnChecked);
+			editor.putInt("enable", 0);
+	           }
+				
+		   editor.commit();
+		} catch (IOException re) {
+		   Log.e(TAG, "IO Exception");
+		}
+	   } else {
+		Log.i(TAG, "The File " + file + " is not exists");
+	   }
+	}else{
+           if (file.exists()) {
+		try {
+		    Log.d(TAG,"setHdmiConfig");
+		    SharedPreferences.Editor editor = getActivity().getPreferences(0).edit();
+		    String strChecked = "1";
+		    String strUnChecked = "0";		
+		    RandomAccessFile rdf = null;
+		    rdf = new RandomAccessFile(file, "rw");
+		    if (enable) {
+			rdf.writeBytes(strChecked);
+			editor.putInt("enable", 1);
+		    } else {
+			rdf.writeBytes(strUnChecked);
+			editor.putInt("enable", 0);
+		    }
+		    editor.commit();
+		} catch (IOException re) {
+		    Log.e(TAG, "IO Exception");
+		    re.printStackTrace();
+		}
+	    } else {
+		Log.i(TAG, "The File " + file + " is not exists");
+	    }
+	}
+    }
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
+    		Preference preference) {
+    	// TODO Auto-generated method stub
+    	
+    	
+    		if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+		{
+			if (true) {
+	        	SharedPreferences  mPreferences = getPreferenceScreen().getSharedPreferences();
+		        SharedPreferences  sharedPrefs = getActivity().getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+		        SharedPreferences.Editor  editor = sharedPrefs.edit();
+	                boolean isConnected = isHdmiConnected(HdmiState);
+	                int timeout = mPreferences.getInt("timeout", 30000);
+
+			if (preference == mHdmi) {
+				if (mHdmi.isChecked()) {
+						setHdmiConfig(HdmiFile, true);
+						mHdmi.setChecked(true);
+						// save config
+						editor.putInt("enable", 1);
+				} else {
+					setHdmiConfig(HdmiFile, false);
+					mHdmi.setChecked(false);
+					editor.putInt("enable", 0);
+
+			    }
+				editor.commit();
+			} else if (preference == mHdcp) {
+				String strHdcp = "hdmi_hdcp";
+				if (mHdcp.isChecked()) {
+					setHdmiOutputStyle(HdmiState, 1, strHdcp);
+					mHdcp.setChecked(false);// not open HDCP now
+				} else {
+					setHdmiOutputStyle(HdmiState, 0, strHdcp);
+					mHdcp.setChecked(false);
+				}
+			}
+		}
+			
+			
+		}
+      else{	
+    	if (true) {
+        	SharedPreferences  mPreferences = getPreferenceScreen().getSharedPreferences();
+	        SharedPreferences  sharedPrefs = getActivity().getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+	        SharedPreferences.Editor  editor = sharedPrefs.edit();
+                boolean isConnected = isHdmiConnected(HdmiState);
+                int timeout = mPreferences.getInt("timeout", 30000);
+                Log.d(TAG, "onPreferenceThreeClick() ==>> isConnected=" + isConnected);
+
+		if (preference == mHdmi) {
+			if (mHdmi.isChecked()) {
+ 
+				setHdmiConfig(HdmiDisplayEnable,true);
+				mHdmi.setChecked(true);
+				
+			} else {
+				setHdmiConfig(HdmiDisplayEnable, false);
+				mHdmi.setChecked(false);
+				editor.putInt("enable", 0);
+
+				int mFlag = mPreferences.getInt("mAccelerometer", 0);
+				if (mFlag != 0) {
+			}
+		    }
+			editor.commit();
+		} else if (preference == mHdcp) {
+			String strHdcp = "hdmi_hdcp";
+			if (mHdcp.isChecked()) {
+				setHdmiOutputStyle(HdmiState, 1, strHdcp);
+				mHdcp.setChecked(false);// not open HDCP now
+			} else {
+				setHdmiOutputStyle(HdmiState, 0, strHdcp);
+				mHdcp.setChecked(false);
+			}
+		} 
+	}
+     }
+	return true;
+    }
+
+     private void setHdmiLcdTimeout(int value){
+        if(value != -1){
+	    value = (value) * 10;
+	}
+        try {
+            Settings.System.putInt(getContentResolver(), Settings.System.HDMI_LCD_TIMEOUT, value);
+        } catch (NumberFormatException e) {
+            Log.e(TAG, "could not persist hdmi lcd timeout setting", e);
+        }
+      }  
+	@Override
+      public boolean onPreferenceChange(Preference preference, Object objValue) {
+		// TODO Auto-generated method stub
+	if(SystemProperties.get("ro.board.platform","none").equals("rk29xx")){
+	   if (true){
+		SharedPreferences.Editor editor = getActivity().getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE).edit();
+		final String key = preference.getKey();
+		if (KEY_HDMI_RESOLUTION.equals(key)){		
+			
+		    try {
+			String strResolution = "hdmi_resolution";
+			int value = Integer.parseInt((String) objValue);
+			editor.putInt("resolution", value);		
+			setHdmiOutputStyle(HdmiState, value, strResolution);
+			} catch (NumberFormatException e){
+				Log.e(TAG, "onPreferenceChanged hdmi_resolution setting error");
+			}
+		}
+
+		if (KEY_HDMI_MODE.equals(key)){
+		    try {
+			String strMode = "hdmi_mode";
+			int value = Integer.parseInt((String) objValue);
+			editor.putInt("mode", value);
+			setHdmiOutputStyle(HdmiState, value, strMode);
+			} catch (NumberFormatException e){
+				Log.e(TAG, "onPreferenceChanged hdmi_mode setting error");
+			}
+		}
+			
+		editor.commit();
+			
+		/*	if (KEY_HDMI_LCD.equals(key)){
+				try {
+					String strMode = "hdmi_display";
+					int value = Integer.parseInt((String) objValue);
+					//editor.putInt("enable", value);
+					setHdmiLcdTimeout(value);
+				} catch (NumberFormatException e){
+					Log.e(TAG, "onPreferenceChanged hdmi_mode setting error");
+				}
+			} */
+		}
+			
+			
+	}else{
+	       if (true){
+			SharedPreferences.Editor editor = getActivity().getPreferences(0).edit();
+			final String key = preference.getKey();
+			if (KEY_HDMI_RESOLUTION.equals(key)){
+		            try {
+				String strResolution = "hdmi_resolution";
+				int value = Integer.parseInt((String) objValue);
+				editor.putInt("resolution", value);
+				setHdmiOutputStyle(HdmiDisplayMode, value, strResolution);
+				} catch (NumberFormatException e){
+					Log.e(TAG, "onPreferenceChanged hdmi_resolution setting error");
+				}
+			}
+
+			if (KEY_HDMI_MODE.equals(key)){
+				try {
+					String strMode = "hdmi_mode";
+					int value = Integer.parseInt((String) objValue);
+					editor.putInt("mode", value);
+					setHdmiOutputStyle(HdmiState, value, strMode);
+				} catch (NumberFormatException e){
+					Log.e(TAG, "onPreferenceChanged hdmi_mode setting error");
+				}
+			}
+                        if (KEY_HDMI_LCD.equals(key)){
+				try {
+					String strMode = "hdmi_display";
+					int value = Integer.parseInt((String) objValue);
+					//editor.putInt("enable", value);
+					setHdmiLcdTimeout(value);
+				} catch (NumberFormatException e){
+					Log.e(TAG, "onPreferenceChanged hdmi_mode setting error");
+				}
+			}
+			editor.commit();
+		}
+	  }
+	  return true;
+	}
+    
+	
+	public static boolean isHdmiConnected(File file){
+        boolean isConnected = false;
+        if (file.exists()){
+            try {
+                  FileReader       fread = new FileReader(file);
+                  BufferedReader   buffer = new BufferedReader(fread);
+                  String           strPlug = "plug=1";
+                  String           str = null;
+
+                  while ((str = buffer.readLine()) != null){
+                    int length = str.length();
+                   // if((length == 6) && (str.equals(strPlug))){
+                    if(str.equals("1")){
+                        isConnected = true;
+                        break;
+                    }
+                    else{
+                        //isConnected = false;
+                    }
+                  }
+            } catch (IOException e){
+                Log.e(TAG, "IO Exception");
+            }
+        }
+        return isConnected;
+    }
+	
+	protected void setHdmiOutputStyle(File file, int style, String string){
+		
+	   if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+		{
+			 if (file.exists()){
+		 	   try {
+				FileReader		fread  = new FileReader(file);
+				BufferedReader 	buffer = new BufferedReader(fread);
+				StringBuffer	strbuf = new StringBuffer(""); 	
+				String			str = null;
+				String  		substr = null;
+				SharedPreferences.Editor editor = getActivity().getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE).edit();
+				if (string.equals("hdmi_resolution")){		
+					substr = "resolution";
+					if(style == 6)
+					{
+					}
+					else
+					{
+						style--;
+					}
+					while ((str = buffer.readLine()) != null){
+					    if (str.length() == 12){
+						String  res = str.substring(0, 10);	
+						if (substr.equals(res)){ 
+						   String strValue = String.valueOf(style);
+						   String s = substr + "=" + strValue;
+						   strbuf.append(s + "\n");
+						   //for save config
+					           editor.putInt("resolution", Integer.parseInt(strValue));
+						   editor.commit();
+						}else{
+						   strbuf.append(str + "\n");
+						}
+					     }else{
+						   strbuf.append(str + "\n");
+					     }
+					}
+				}
+
+				if (string.equals("hdmi_mode")){
+					boolean flag = false;
+					substr = "mode";
+						
+					while ((str = buffer.readLine()) != null){ 
+					    if (str.length() == 6){
+						String res = str.substring(0, 4);
+						if (substr.equals(res)){
+							flag = true;
+							String strValue = String.valueOf(style);
+							String s = substr + "=" + strValue;
+							strbuf.append(s + "\n");
+							editor.putInt("mode",  Integer.parseInt(strValue));
+							editor.commit();
+						}else{
+							strbuf.append(str + "\n");
+						}
+					     }else{
+							strbuf.append(str + "\n");
+				  	     }
+					}
+						
+					if (!flag){
+						String s = "mode=0";
+						strbuf.append(s + "\n");
+						editor.putInt("mode", 0);
+						editor.commit();
+					}
+				}
+
+				if (string.equals("hdmi_hdcp")){
+					substr = "hdcp_on";
+					while ((str = buffer.readLine()) != null){
+
+						if (str.length() == 9){
+							String res = str.substring(0, 7);
+							if (substr.equals(res)){
+								String strValue = String.valueOf(style);
+								String s = substr + "=" + strValue;
+								strbuf.append(s + "\n");
+								editor.putInt("hdcp_on", Integer.parseInt(strValue));
+								editor.commit();
+							}else{
+								strbuf.append(str + "\n");
+								}
+						}else{
+							strbuf.append(str + "\n");
+						}
+					}
+				}
+
+
+				buffer.close();
+				fread.close();
+
+				//write into file
+				File f = new File("/sys/class/hdmi/hdmi-0/state");
+				OutputStream output = null;
+				OutputStreamWriter outputWrite = null;
+				PrintWriter	 print = null;
+					
+				try{
+					output = new FileOutputStream(f);
+					outputWrite = new OutputStreamWriter(output);
+					print = new PrintWriter(outputWrite);
+					print.print(strbuf.toString());
+					print.flush();
+					output.close();
+				} catch (FileNotFoundException e) {
+						e.printStackTrace();
+				}
+			} catch (IOException e){
+				Log.e(TAG, "IO Exception");
+			}
+	          }else{
+				Log.i(TAG, "The File " + file + " is not exists");
+		}
+			
+	  }else{
+		if (file.exists()){
+		    try {
+			FileReader fread  = new FileReader(file);
+			BufferedReader 	buffer = new BufferedReader(fread);
+			StringBuffer	strbuf = new StringBuffer(""); 	
+			Log.d(TAG,"setHdmiOutputStyle");
+			if (string.equals("hdmi_resolution")){
+	                     switch(style){
+				case 1:
+					strbuf.append("1920x1080p-50\n");
+					break;
+				case 2:
+					strbuf.append("1920x1080p-60\n");
+					break;
+				case 3: 
+					strbuf.append("1280x720p-50\n");
+			                break;
+				case 4:
+					strbuf.append("1280x720p-60\n");
+					break;
+				case 5:
+					strbuf.append("720x576p-50\n");
+					break;
+				case 6:
+					strbuf.append("720x480p-60\n");
+					break;
+					}
+				}
+	
+				
+	
+				buffer.close();
+				fread.close();
+	
+				//write into file
+				File f = new File("/sys/class/display/HDMI/mode");
+				OutputStream output = null;
+				OutputStreamWriter outputWrite = null;
+				PrintWriter	 print = null;
+					
+				try{
+				   output = new FileOutputStream(f);
+				   outputWrite = new OutputStreamWriter(output);
+				   print = new PrintWriter(outputWrite);
+	                           Log.d(TAG,"strbuf="+strbuf.toString());
+				   print.print(strbuf.toString());
+				   //print.print("1920x1080p-50");
+	                           print.flush();
+				   output.close();
+	                 	} catch (FileNotFoundException e) {
+				   e.printStackTrace();
+				}
+			} catch (IOException e){
+	                         e.printStackTrace();
+	
+				Log.e(TAG, "IO Exception");
+			}
+		}else{
+				Log.i(TAG, "The File " + file + " is not exists");
+		}
+	}
+ }
+}
diff --git a/src/com/android/settings/HdmiReceiver.java b/src/com/android/settings/HdmiReceiver.java
new file mode 100644
index 0000000..b697b14
--- /dev/null
+++ b/src/com/android/settings/HdmiReceiver.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.BroadcastReceiver;
+import android.os.RemoteException;
+import android.os.IPowerManager;
+import android.os.ServiceManager;
+import android.preference.SeekBarPreference;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
+import android.util.AttributeSet;
+import android.util.Log;
+
+import java.util.Map;
+
+import java.io.*;
+import android.os.SystemProperties;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.os.SystemProperties;
+import android.content.ContentResolver;
+import java.io.RandomAccessFile;
+import static android.provider.Settings.System.HDMI_LCD_TIMEOUT;
+public class HdmiReceiver extends BroadcastReceiver{
+        private final String ACTION = "android.intent.action.HDMI_AUDIO_PLUG";
+	private static final String TAG = "HdmiReceiver";
+	private File HdmiState = new File("/sys/class/hdmi/hdmi-0/state");
+	private File HdmiFile = new File("/sys/class/hdmi/hdmi-0/enable");
+	private File HdmiDisplayEnable=new File("/sys/class/display/HDMI/enable");
+        private File HdmiDisplayMode=new File("/sys/class/display/HDMI/mode");
+        private File HdmiDisplayScale=new File("/sys/class/display/HDMI/scale");
+	Context mcontext;
+	
+    @Override
+    public void onReceive(Context context, Intent intent){
+    	mcontext = context;
+        if (intent.getAction().equals(ACTION)){
+		if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+		   {
+			SharedPreferences preferences = context.getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+		        int enable = preferences.getInt("enable", 1);
+			int scale = preferences.getInt("scale_set", 100);
+			int resol = preferences.getInt("resolution", 3);
+		        restoreHdmiValue(HdmiFile, enable, "enable");
+                        restoreHdmiValue(HdmiState, scale, "hdmi_scale");
+                        //Log.d(TAG,"rk29board ----enable ="+String.valueOf(enable));
+			restoreHdmiValue(HdmiState, resol, "hdmi_resolution");
+		        SharedPreferences.Editor  editor = preferences.edit();
+		        editor.putInt("enable", enable);
+			//restoreDoubleScreenDisplay(HdmiFile);
+                        Log.d(TAG,"rk2918board ----enable ="+String.valueOf(enable)+ " scale="+String.valueOf(scale)+" resol="+String.valueOf(resol));
+		}else
+		   {
+		        SharedPreferences preferences = context.getSharedPreferences("Settings", context.MODE_PRIVATE);
+                        int enable = preferences.getInt("enable", 1);
+			int resol = preferences.getInt("resolution", 2);
+                        //Log.d(TAG,"enable ="+String.valueOf(enable));
+                        restoreHdmiValue(HdmiDisplayEnable, enable, "enable");
+			restoreHdmiValue(HdmiDisplayMode, resol, "hdmi_resolution");
+                        SharedPreferences preferences_scale = context.getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+                        int scale=preferences_scale.getInt("scale_set",100);
+                        restoreHdmiValue(HdmiDisplayScale,scale,"hdmi_scale");
+                        if(getFBDualDisplayMode()==1){
+                           int state=intent.getIntExtra("state", 1);
+                           if(state==1){
+                           SystemProperties.set("sys.hdmi_screen.scale",String.valueOf((char)scale));
+                           }else{
+                           SystemProperties.set("sys.hdmi_screen.scale",String.valueOf((char)100)); 
+                           }
+                        }
+                        if(getFBDualDisplayMode()!=0){
+                           TurnonScreen("0");
+                        }
+                        Log.d(TAG,"enable ="+String.valueOf(enable)+ " scale="+String.valueOf(scale)+" resol="+String.valueOf(resol));
+	       }
+              
+        }
+    }
+    
+   
+      private void TurnonScreen(String str){
+        Log.d("dzy","WIRE TurnOnScreen"+String.valueOf(str));
+                //boolean ff = SystemProperties.getBoolean("persist.sys.hdmi_screen", false);
+                ContentResolver resolver = mcontext.getContentResolver();
+                final long currentTimeout = Settings.System.getLong(resolver, HDMI_LCD_TIMEOUT,
+                -1);
+
+                File HdmiFile = new File("/sys/class/graphics/fb0/blank");
+
+                try {
+                        Log.d("dzy","turn on screen");
+                        RandomAccessFile rdf = null;
+                        rdf = new RandomAccessFile(HdmiFile, "rw");
+                        rdf.writeBytes(str);
+                } catch (IOException re) {
+                        Log.e(TAG, "IO Exception");
+                }
+
+
+    }
+         private int getFBDualDisplayMode(){
+            int mode = 0;
+            File DualModeFile = new File("/sys/class/graphics/fb0/dual_mode");
+            if(DualModeFile.exists()){
+                    try {
+                            byte[] buf = new byte[10];
+                            int len = 0;
+                            RandomAccessFile rdf = new RandomAccessFile(DualModeFile, "r");
+                            len = rdf.read(buf);
+                            String modeStr = new String(buf,0,1);
+                            mode = Integer.valueOf(modeStr);
+                    } catch (IOException re) {
+                            Log.e(TAG, "IO Exception");
+                    } catch (NumberFormatException re) {
+                            Log.e(TAG, "NumberFormatException");
+                    }
+            }
+            return mode;
+    }
+
+	 protected void restoreDoubleScreenDisplay(File file){
+		if (file.exists()){
+			try {
+				if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+			{
+					SharedPreferences  sharedPreferences1 = mcontext.getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+				 int enable = sharedPreferences1.getInt("enable", 0);
+				String strDouble = "2";
+				RandomAccessFile rdf = null;
+				rdf = new RandomAccessFile(file, "rw");
+				if(enable == 0){
+					rdf.writeBytes("0");
+				}else {
+					rdf.writeBytes(strDouble);
+				} 
+				
+			}else
+			{
+				SharedPreferences  sharedPreferences1 = mcontext.getSharedPreferences("HdmiSettings", Context.MODE_PRIVATE);
+				SharedPreferences.Editor editor = sharedPreferences1.edit();
+				String strDouble = "2";
+				RandomAccessFile rdf = null;
+				rdf = new RandomAccessFile(file, "rw");
+				
+				if(HdmiControllerActivity.isHdmiConnected(HdmiState)){
+					editor.putInt("enable", 2);
+				}else{
+					editor.putInt("enable", 0);
+				}
+				
+				//SystemProperties.set("persist.sys.hdmi_screen", "1");
+				editor.commit();
+				}
+			} catch (IOException re) {
+				Log.e(TAG, "IO Exception");
+			}
+		}else{
+			Log.e(TAG, "File:" + file + "not exists");
+		}
+	}
+
+
+	protected void restoreHdmiValue(File file, int value, String style){
+                //Log.d(TAG,"restoreHdmiValue------------------------------");
+		if (file.exists()){
+                        //Log.d(TAG,"exists-------------------");
+				try {
+						FileReader		fread  = new FileReader(file);
+						BufferedReader 	buffer = new BufferedReader(fread);
+						StringBuffer	strbuf = new StringBuffer(""); 	
+						String  		substr = null;
+						String			str = null;
+						int				length = 0;	
+	
+			if(SystemProperties.get("ro.board.platform","none").equals("rk29xx")){
+                               Log.d(TAG,"rk29---------------------");
+			       if(style.equals("enable")){
+				   Log.d(TAG,"restoreHdmiValue enable");
+				   RandomAccessFile rdf = null;
+				   rdf = new RandomAccessFile(HdmiFile, "rw");
+				   if(value >= 1)
+					{
+					   if(HdmiControllerActivity.isHdmiEnableDoubleScreen(HdmiState))
+					    {
+						 rdf.writeBytes(String.valueOf(2));
+					    }else
+					    {
+						 rdf.writeBytes(String.valueOf(value));
+					    }
+				    }else{
+							rdf.writeBytes(String.valueOf(value));
+			            }
+				}else{
+				if (style.equals("hdmi_scale")){	
+					substr = "scale_set";
+					while ((str = buffer.readLine()) != null){
+					length = str.length();
+					if (length == 13 || length == 12){
+						String res = str.substring(0, 9);
+						if (substr.equals(res)){
+						String strValue = String.valueOf(value);
+						String s = substr + "=" + strValue;
+						strbuf.append(s + "\n");
+					}else
+					{
+						strbuf.append(str + "\n");
+					}
+					}
+                                 else{
+						strbuf.append(str + "\n");
+								}
+							}
+						}
+
+						if (style.equals("hdmi_resolution")){
+							substr = "resolution";
+							while ((str = buffer.readLine()) != null){
+								if (str.length() == 12){
+									String res = str.substring(0, 10);
+									if (substr.equals(res)){
+										String strValue = String.valueOf(value);	
+										String s = substr + "=" + strValue;
+										strbuf.append(s + "\n");
+									}else{
+										strbuf.append(str + "\n");
+									}
+
+								}else
+								{
+									strbuf.append(str + "\n");
+								}
+							}							
+						}
+
+						buffer.close();
+						fread.close();
+
+						File f = new File("/sys/class/hdmi/hdmi-0/state");
+						OutputStream output = null;
+						OutputStreamWriter outputWrite = null;
+						PrintWriter print = null;
+
+						try {
+								output = new FileOutputStream(f);
+								outputWrite = new OutputStreamWriter(output);
+								print = new PrintWriter(outputWrite);
+
+								print.print(strbuf.toString());
+								print.flush();
+								output.close();
+						}catch (FileNotFoundException e){
+								e.printStackTrace();
+						}
+					}
+
+			
+			}else
+			{
+
+						if(style.equals("enable")){
+							Log.d(TAG,"restoreHdmiValue enable");
+							RandomAccessFile rdf = null;
+							rdf = new RandomAccessFile(file, "rw");
+							rdf.writeBytes(String.valueOf(value));
+						}
+                                                if(style.equals("hdmi_scale")){
+                                                       OutputStream output = null;
+                                                        OutputStreamWriter outputWrite = null;
+                                                        PrintWriter print = null;
+                                                       strbuf.append(value);
+                                                       try {
+                                                                        output = new FileOutputStream(file);
+                                                                        outputWrite = new OutputStreamWriter(output);
+                                                                        print = new PrintWriter(outputWrite);
+                                                                        print.print(strbuf.toString());
+                                                                        print.flush();
+                                                                        output.close();
+                                                        }catch (FileNotFoundException e){
+                                                                        e.printStackTrace();
+                                                        }
+                                                }
+						if(style.equals("hdmi_resolution")){
+							Log.d(TAG,"restoreHdmiValue hdmi_resolution");
+							OutputStream output = null;
+							OutputStreamWriter outputWrite = null;
+							PrintWriter print = null;
+							switch(value){
+							case 1:
+								strbuf.append("1920x1080p-50\n");
+								break;
+							case 2:
+								strbuf.append("1920x1080p-60\n");
+								break;
+							case 3: 
+								strbuf.append("1280x720p-50\n");
+					            break;
+							case 4:
+								strbuf.append("1280x720p-60\n");
+								break;
+							case 5:
+								strbuf.append("720x576p-50\n");
+								break;
+							case 6:
+								strbuf.append("720x480p-60\n");
+								break;
+							}
+							try {
+									output = new FileOutputStream(file);
+									outputWrite = new OutputStreamWriter(output);
+									print = new PrintWriter(outputWrite);
+
+									print.print(strbuf.toString());
+									print.flush();
+									output.close();
+							}catch (FileNotFoundException e){
+									e.printStackTrace();
+							}
+						}
+                  
+						buffer.close();
+						fread.close();
+
+				  }
+				} catch (IOException e){
+					Log.e(TAG, "IO Exception");
+				}
+
+		}else{
+			Log.e(TAG, "File:" + file + "not exists");
+		}
+	}
+}
+
diff --git a/src/com/android/settings/HdmiScreenZoomPreference.java b/src/com/android/settings/HdmiScreenZoomPreference.java
new file mode 100644
index 0000000..b3e5004
--- /dev/null
+++ b/src/com/android/settings/HdmiScreenZoomPreference.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings;
+import android.util.Log;
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.IPowerManager;
+import android.os.ServiceManager;
+import android.preference.SeekBarPreference;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+import android.widget.SeekBar;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceScreen;
+import android.preference.SeekBarDialogPreference;
+import android.os.SystemProperties;
+import java.util.Map;
+
+import java.io.*;
+import java.io.File;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.io.FileWriter;
+import java.io.Writer;
+import java.io.FileReader;
+import java.io.FileWriter;
+
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+
+public class HdmiScreenZoomPreference extends SeekBarDialogPreference implements
+        SeekBar.OnSeekBarChangeListener, CheckBox.OnCheckedChangeListener {
+
+    private static final String TAG = "HdmiScreenZoomPreference";
+    private static final int MINIMUN_SCREEN_SCALE = 0;
+    private static final int MAXIMUN_SCREEN_SCALE = 20;
+
+    private File HdmiScale = new File("/sys/class/display/HDMI/scale");
+    private SeekBar mSeekBar;
+    private int     mOldScale = 0;
+    private int     mValue = 0;
+    private int     mRestoreValue = 0;
+    private boolean mFlag  = false;
+	//for save hdmi config
+    private	Context	context;
+
+    public HdmiScreenZoomPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        this.context = context;
+        setDialogLayoutResource(R.layout.preference_dialog_screen_scale);
+        setDialogIcon(R.drawable.ic_settings_screen_scale);
+		if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+		{
+			HdmiScale =  new File("/sys/class/hdmi/hdmi-0/state");
+		}
+    }
+
+    protected void setHdmiScreenScale(File file, int value){
+        if (file.exists()){
+ 	    try {
+		StringBuffer	strbuf = new StringBuffer(""); 	
+		if(SystemProperties.get("ro.board.platform","none").equals("rk29xx"))
+		{
+				FileReader		fread  = new FileReader(file);
+				BufferedReader 	buffer = new BufferedReader(fread);
+				String  		substr = "scale_set";
+				String			str = null;
+				int				length = 0;	
+
+				while ((str = buffer.readLine()) != null){
+				    length = str.length();
+				    if (length == 13 || length == 12){
+				        String res = str.substring(0, 9);
+				        if (substr.equals(res)){
+			                 String strValue = String.valueOf(value);
+				         String s = substr + "=" + strValue;
+				         strbuf.append(s + "\n");
+				        }else
+				         {
+					    strbuf.append(str + "\n");
+					 }
+
+				    }else{
+					    strbuf.append(str + "\n");
+				    }
+				}
+				buffer.close();
+				fread.close();
+		}else
+		{
+                strbuf.append(value);
+		}
+		OutputStream output = null;
+		OutputStreamWriter outputWrite = null;
+		PrintWriter print = null;
+
+		try {
+                        //SystemProperties.set("sys.hdmi_screen.scale",String.valueOf(value));
+			output = new FileOutputStream(file);
+			outputWrite = new OutputStreamWriter(output);
+			print = new PrintWriter(outputWrite);
+
+			print.print(strbuf.toString());
+			print.flush();
+			output.close();
+		}catch (FileNotFoundException e){
+			e.printStackTrace();
+		}
+            } catch (IOException e){
+				Log.e(TAG, "IO Exception");
+	     }
+
+	}else{
+			Log.e(TAG, "File:" + file + "not exists");
+	}
+	if(getFBDualDisplayMode() == 1){
+		SystemProperties.set("sys.hdmi_screen.scale",String.valueOf((char)value));
+	}else{
+		SystemProperties.set("sys.hdmi_screen.scale",String.valueOf((char)100));
+	}
+    }
+
+    private int getFBDualDisplayMode(){
+	    int mode = 0;
+	    File DualModeFile = new File("/sys/class/graphics/fb0/dual_mode");
+	    if(DualModeFile.exists()){
+		    try {
+			    byte[] buf = new byte[10];
+			    int len = 0;
+			    RandomAccessFile rdf = new RandomAccessFile(DualModeFile, "r");
+			    len = rdf.read(buf);
+			    String modeStr = new String(buf,0,1);
+			    mode = Integer.valueOf(modeStr);
+		    } catch (IOException re) {
+			    Log.e(TAG, "IO Exception");
+		    } catch (NumberFormatException re) {
+			    Log.e(TAG, "NumberFormatException");
+		    }
+	    }
+	    return mode;
+    }
+
+
+    @Override
+    protected void onBindDialogView(View view) {
+        super.onBindDialogView(view);
+		
+	mFlag = false;
+        mSeekBar = getSeekBar(view);
+	//resotre value
+	SharedPreferences preferences = context.getSharedPreferences("HdmiSettings", context.MODE_PRIVATE);
+	mOldScale = preferences.getInt("scale_set", 100);
+	mOldScale = mOldScale - 80;
+		
+        mSeekBar.setProgress(mOldScale);
+        mSeekBar.setOnSeekBarChangeListener(this);
+    }
+
+    public void onProgressChanged(SeekBar seekBar, int progress,
+            boolean fromTouch) {
+	mValue = progress + 80;
+	if (mValue > 100){
+		mValue = 100;
+	}
+	setHdmiScreenScale(HdmiScale, mValue);
+    }
+
+    public void onStartTrackingTouch(SeekBar seekBar) {
+	//If start tracking, record the initial position
+	mFlag = true;
+	mRestoreValue = seekBar.getProgress();
+    }
+
+    public void onStopTrackingTouch(SeekBar seekBar) {
+	setHdmiScreenScale(HdmiScale, mValue);
+    }
+
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked){
+
+    }
+
+
+    @Override
+    protected void onDialogClosed(boolean positiveResult) {
+        super.onDialogClosed(positiveResult);
+	//for save config
+	SharedPreferences preferences = context.getSharedPreferences("HdmiSettings", context.MODE_PRIVATE);
+	SharedPreferences.Editor	editor = preferences.edit();
+
+	if (positiveResult){
+		int value = mSeekBar.getProgress() + 80;
+		setHdmiScreenScale(HdmiScale, value);
+	        editor.putInt("scale_set", value);
+	}else{
+		if (mFlag){
+			mRestoreValue = mRestoreValue + 80;
+			if (mRestoreValue > 100){
+				mRestoreValue = 100;
+			}
+			setHdmiScreenScale(HdmiScale, mRestoreValue);
+			editor.putInt("scale_set", mRestoreValue);
+		}else{
+			//click cancel without any other operations
+			int value = mSeekBar.getProgress() + 80;
+			setHdmiScreenScale(HdmiScale, value);
+			editor.putInt("scale_set", value);
+		}
+	}
+			editor.commit();
+        }
+   }
+
diff --git a/src/com/android/settings/Settings.java b/src/com/android/settings/Settings.java
index b3f50f8..6b5697f 100644
--- a/src/com/android/settings/Settings.java
+++ b/src/com/android/settings/Settings.java
@@ -48,6 +48,7 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.os.SystemProperties;
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.preference.PreferenceFragment;
@@ -69,6 +70,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
+import java.io.File;
 
 /**
  * Top-level settings activity to handle single pane and double pane UI layout.
@@ -431,6 +433,16 @@ public class Settings extends PreferenceActivity
 
         updateHeaderList(headers);
     }
+    
+    private boolean hasHdmiFeature(){
+    	File file30=new File("/sys/class/display/HDMI/enable");
+    	File file29=new File("/sys/class/hdmi/hdmi-0/enable");
+    	if(file30.exists()||file29.exists()){
+    		return true;
+    	}else{
+    		return false;
+    	}
+    }
 
     private void updateHeaderList(List<Header> target) {
         final boolean showDev = mDevelopmentPreferences.getBoolean(
@@ -493,6 +505,10 @@ public class Settings extends PreferenceActivity
                         || Utils.isMonkeyRunning()) {
                     target.remove(i);
                 }
+            } else if(id == R.id.hdmi_settings){
+            	if(!hasHdmiFeature()){
+            		target.remove(header);
+            	}
             } else if (id == R.id.development_settings
                     || id == R.id.performance_settings) {
                 if (!showDev) {
-- 
1.8.1.2

